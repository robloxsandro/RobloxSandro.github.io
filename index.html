<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Demo — Liquid Glass & Zentrierter Ripple</title>

<!-- Montserrat (heavy) -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&display=swap" rel="stylesheet">

<style>
:root{
  --bg-dark: #041b13;       /* deutlich dunkleres Grün */
  --bg-mid:  #0b3a24;
  --bg-light:#2ba76a;
  --accent:  #bff7c9;
  --glass-border: rgba(255,255,255,0.08);
  --glass-fill: rgba(255,255,255,0.04);
  --text: #eafaf0;
}

/* Grund */
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:"Montserrat",system-ui,-apple-system,"Segoe UI",Roboto,Arial;color:var(--text);background:transparent;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}

/* ANIMIERTER HINTERGRUND (rotierender Farbverlauf) */
.bg-gradient {
  position:fixed; inset:0; z-index:-3; overflow:hidden;
  background: linear-gradient(110deg, var(--bg-dark) 0%, var(--bg-mid) 40%, var(--bg-light) 100%);
  background-size: 300% 300%;
  animation: gradientShift 28s linear infinite;
  filter: saturate(110%);
}
.bg-gradient::after{
  content:""; position:absolute; inset:-30%;
  background: radial-gradient(closest-side, rgba(255,255,255,0.02), transparent 30%),
              conic-gradient(from 180deg at 50% 50%, rgba(255,255,255,0.02), transparent 25%);
  transform: rotate(90deg);
  animation: rotateSlow 48s linear infinite;
}
@keyframes gradientShift{
  0%{ background-position:0% 50%; }
  50%{ background-position:100% 50%; }
  100%{ background-position:0% 50%; }
}
@keyframes rotateSlow{
  0%{ transform: rotate(0deg) scale(1.06); }
  100%{ transform: rotate(360deg) scale(1.06); }
}

/* PARTICLE CANVAS sits behind the frame */
#bg-particles{ position:fixed; left:0; top:0; width:100%; height:100%; z-index:-2; pointer-events:none; }

/* Layout */
.container { max-width:1100px; margin:48px auto; padding:24px; }
.header { display:flex; align-items:center; justify-content:space-between; gap:20px; margin-bottom:28px; }
.logo { font-size:1.4rem; font-weight:900; letter-spacing:-0.6px; color:var(--text); }
.nav { display:flex; gap:12px; align-items:center; }
a { color:var(--accent); text-decoration:none; position:relative; border-radius:8px; -webkit-tap-highlight-color:transparent; transition:transform .12s ease, opacity .12s ease; }
a:visited { color:var(--accent); } /* kein lila */
a:hover { transform: translateY(-2px); }
a[aria-current="page"]{ box-shadow: 0 6px 30px rgba(0,0,0,0.36) inset; }

/* GLASS / FRAME */
.glass {
  background: var(--glass-fill);
  border: 1px solid var(--glass-border);
  border-radius: 16px;
  backdrop-filter: blur(10px) saturate(130%);
  -webkit-backdrop-filter: blur(10px) saturate(130%);
  box-shadow: 0 18px 50px rgba(2,6,10,0.55);
  padding: 28px;
  transition: transform .35s cubic-bezier(.2,.9,.2,1), opacity .33s;
}

/* Einblend-Animationen (z.B. für Sections) */
.reveal { opacity:0; transform: translateY(12px) scale(.997); transition: opacity .7s ease, transform .7s cubic-bezier(.2,.9,.2,1); will-change: transform, opacity; }
.reveal.is-visible { opacity:1; transform: translateY(0) scale(1); }

/* Typo */
h1 { font-size:2.2rem; margin:0 0 8px 0; font-weight:900; letter-spacing:-0.6px; }
.lead { color: rgba(234,250,240,0.9); margin:0 0 18px 0; }

/* Buttons */
.button {
  display:inline-block; padding:.6rem 1rem; border-radius:12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  border: 1px solid rgba(255,255,255,0.06); color:var(--text); cursor:pointer;
}

/* LINK RIPPLE (zentral) */
.ripple-effect {
  position: absolute;
  left: 50%; top: 50%;
  transform: translate(-50%,-50%) scale(0);
  background: rgba(255,255,255,0.98);
  opacity: 0.95;
  pointer-events: none;
  border-radius: 50%;
  will-change: transform, opacity;
}
.ripple-animate {
  transform: translate(-50%,-50%) scale(1);
  opacity: 0;
  transition: transform 520ms cubic-bezier(.2,.8,.2,1), opacity 520ms linear;
}

/* small helpers */
.section { padding:18px 0; display:flex; gap:24px; align-items:flex-start; }
.card { flex:1; padding:18px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); }

/* responsive */
@media (max-width:820px){ .header{ flex-direction:column; align-items:flex-start } .container{ padding:16px } h1{ font-size:1.6rem } }
</style>
</head>
<body>

<!-- animated gradient background -->
<div class="bg-gradient" aria-hidden="true"></div>

<!-- particle canvas (created by JS if not present) -->
<canvas id="bg-particles" aria-hidden="true"></canvas>

<div class="container">
  <header class="header">
    <div class="logo">Dein Projekt</div>
    <nav class="nav" aria-label="Hauptnavigation">
      <a href="#home" class="nav-link" aria-current="page">Home</a>
      <a href="#features" class="nav-link">Features</a>
      <a href="#demo" class="nav-link" data-no-delay="1">Sofort (kein Delay)</a>
      <a href="https://example.com" class="nav-link" target="_blank" rel="noopener">Externe Seite</a>
    </nav>
  </header>

  <main class="glass" role="main">
    <section id="home" class="reveal">
      <h1>Stylish · Lebendig · Präzise</h1>
      <p class="lead">Liquid-Glass-Optik, Montserrat-ähnliche Typo und ein deutlicher, zentrierter Klick-Effekt — Navigation verzögert um 0.3s damit der Effekt sichtbar ist.</p>

      <div class="section">
        <div class="card reveal">
          <h3>Design</h3>
          <p>Glasoptik, rotierender Hintergrundverlauf und subtile Partikel geben Tiefe.</p>
          <p><a class="button" href="#features">Mehr erfahren</a></p>
        </div>

        <div class="card reveal">
          <h3>Interaktion</h3>
          <p>Zentrierter Ripple, Verzögerung 300ms vor Navigation (außer modifier / neues Tab / externe Links).</p>
          <p><a class="button" href="#demo">Demo</a></p>
        </div>
      </div>
    </section>

    <section id="features" class="reveal" style="margin-top:14px;">
      <h2 style="margin-top:0">Features</h2>
      <ul>
        <li>Montserrat-heavy Look</li>
        <li>Keine lila/blauen visited Links</li>
        <li>Reveal-on-scroll Animationen</li>
        <li>Partikel & rotierender Verlauf</li>
      </ul>
      <p><a href="#home" class="nav-link">Zurück nach oben</a></p>
    </section>

    <section id="demo" class="reveal" style="margin-top:16px;">
      <h2>Demo Links</h2>
      <p>Probiere diese Links — der mittlere zeigt den no-delay Fall:</p>
      <p>
        <a href="#home" class="nav-link">Standard Link (verzögert 0.3s)</a> &nbsp;
        <a href="#features" class="nav-link" data-no-delay="1">Kein Delay (data-no-delay)</a> &nbsp;
        <a href="https://example.com" class="nav-link" target="_blank">target="_blank" (kein Delay)</a>
      </p>
    </section>
  </main>
</div>

<script>
/* ---------- Interaction + Particles + Reveal ---------- */
(function() {
  /* Helper: is external origin */
  function isExternal(href) {
    try { const u = new URL(href, location.href); return u.origin !== location.origin; }
    catch(e){ return false; }
  }

  /* Ripple + delayed navigation */
  function handleClick(ev) {
    // only handle left click
    if (ev.button !== 0) return;
    const el = ev.target.closest('a');
    if (!el || !el.href) return;

    // conditions to skip delay
    if (el.hasAttribute('data-no-delay')) return;
    if (ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey) return;
    if (el.target === "_blank") return;
    if (el.getAttribute('href') && el.getAttribute('href').startsWith('#')) return;
    if (isExternal(el.href)) return;

    ev.preventDefault();

    // create central ripple element (sized to cover)
    let r = el.querySelector('.ripple-effect');
    if (r) r.remove();
    r = document.createElement('span');
    r.className = 'ripple-effect';

    // ensure parent positioning
    const cs = getComputedStyle(el);
    if (cs.position === 'static') el.style.position = 'relative';

    // set size so expansion covers the element
    const rect = el.getBoundingClientRect();
    const diameter = Math.max(rect.width, rect.height) * 2; // *2 to ensure full cover
    r.style.width = r.style.height = diameter + 'px';
    r.style.marginLeft = -(diameter/2) + 'px';
    r.style.marginTop = -(diameter/2) + 'px';
    r.style.left = '50%';
    r.style.top = '50%';
    r.style.borderRadius = '50%';
    r.style.opacity = '0.98';
    el.appendChild(r);

    // force reflow then animate
    requestAnimationFrame(() => r.classList.add('ripple-animate'));

    // cleanup after animation
    setTimeout(() => { try{ r.remove(); }catch(e){} }, 750);

    // delay navigation to let user see the ripple
    setTimeout(() => {
      // safety: might be removed from DOM or have changed - attempt navigation
      window.location.href = el.href;
    }, 300); // 300ms per Wunsch
  }

  /* Keyboard activation for Enter / Space */
  function handleKeyDown(ev) {
    if (ev.key !== 'Enter' && ev.key !== ' ') return;
    const el = ev.target.closest('a');
    if (!el || !el.href) return;
    if (el.hasAttribute('data-no-delay')) return;
    if (el.target === "_blank") return;
    if (isExternal(el.href)) return;
    if (el.getAttribute('href') && el.getAttribute('href').startsWith('#')) return;
    ev.preventDefault();

    // create ripple same as click
    let r = el.querySelector('.ripple-effect');
    if (r) r.remove();
    r = document.createElement('span');
    r.className = 'ripple-effect';
    const cs = getComputedStyle(el);
    if (cs.position === 'static') el.style.position = 'relative';
    const rect = el.getBoundingClientRect();
    const diameter = Math.max(rect.width, rect.height) * 2;
    r.style.width = r.style.height = diameter + 'px';
    r.style.marginLeft = -(diameter/2) + 'px';
    r.style.marginTop = -(diameter/2) + 'px';
    r.style.left = '50%';
    r.style.top = '50%';
    r.style.borderRadius = '50%';
    el.appendChild(r);
    requestAnimationFrame(() => r.classList.add('ripple-animate'));
    setTimeout(() => { try{ r.remove(); }catch(e){} }, 750);
    setTimeout(() => { window.location.href = el.href; }, 300);
  }

  document.addEventListener('click', handleClick, true);
  document.addEventListener('keydown', handleKeyDown, true);

  /* Reveal on scroll */
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) e.target.classList.add('is-visible');
    });
  }, { threshold: 0.12 });
  document.querySelectorAll('.reveal').forEach(el => observer.observe(el));

  /* Simple particle system (canvas) */
  (function createParticles(){
    const canvas = document.getElementById('bg-particles');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let W = canvas.width = innerWidth;
    let H = canvas.height = innerHeight;
    let ratio = window.devicePixelRatio || 1;
    canvas.width = innerWidth * ratio;
    canvas.height = innerHeight * ratio;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.scale(ratio, ratio);

    const N = Math.round(Math.max(12, (W*H)/140000));
    const parts = [];
    function rand(min,max){ return Math.random()*(max-min)+min; }
    for (let i=0;i<N;i++){
      parts.push({
        x: rand(0,W),
        y: rand(0,H),
        r: rand(0.6,2.4),
        vx: rand(-0.03,0.03),
        vy: rand(-0.02,0.02),
        a: rand(0.06,0.18),
        sway: rand(0.002,0.008),
        t: rand(0,Math.PI*2)
      });
    }
    window.addEventListener('resize', () => {
      W = canvas.width = innerWidth * ratio;
      H = canvas.height = innerHeight * ratio;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(ratio,0,0,ratio,0,0);
    }, { passive:true });

    function draw(){
      ctx.clearRect(0,0,innerWidth,innerHeight);
      for (let p of parts){
        p.t += p.sway;
        p.x += p.vx + Math.sin(p.t)*0.08;
        p.y += p.vy + Math.cos(p.t)*0.02;
        if (p.x < -50) p.x = innerWidth + 50;
        if (p.x > innerWidth + 50) p.x = -50;
        if (p.y < -50) p.y = innerHeight + 50;
        if (p.y > innerHeight + 50) p.y = -50;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,' + p.a + ')';
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();
      }
      requestAnimationFrame(draw);
    }
    draw();
  })();

  // ensure initial reveal for visible items on load
  window.addEventListener('load', () => {
    document.querySelectorAll('.reveal').forEach(el => {
      const r = el.getBoundingClientRect();
      if (r.top < window.innerHeight) el.classList.add('is-visible');
    });
  });

})();
</script>
</body>
</html>
